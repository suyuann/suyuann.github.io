<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>经验风险最小化</title>
    <url>/2020/03/30/%E7%BB%8F%E9%AA%8C%E9%A3%8E%E9%99%A9%E6%9C%80%E5%B0%8F%E5%8C%96/</url>
    <content><![CDATA[<h2 id="经验风险最小化和结构风险最小化"><a href="#经验风险最小化和结构风险最小化" class="headerlink" title="经验风险最小化和结构风险最小化"></a>经验风险最小化和结构风险最小化</h2><p>Empirirical Risk Minimization and Structure Risk Minimization</p>
<hr>
<script type="math/tex; mode=display">
R_{erm}(f)=\frac{1}{N}\sum_{i=1}^{N}L(y_i,f(x_i)) \tag{1}</script><p>经验风险是模型关于训练样本集的平均损失，ERM策略认为，经验风险最小的模型即是最优的模型，根据这一策略，按照ERM求解最优模型就是求解最优化问题。</p>
<script type="math/tex; mode=display">
\min_{f\in F}\frac{1}{N}\sum_{i=1}^{N}L(y_i,f(x_i)) \tag{2}</script><p>在小样本情况下，ERM学习未必很好，容易产生过拟合问题。而结构风险最小化即是为了解决此问题提出的。</p>
<hr>
<p>结构风险最小化注重于对风险上界的最小化，而不是单纯的使经验风险最小化，SRM在ERN的基础上加上了表示模型复杂度的正则化项，在假设空间，损失函数以及训练集确定的情况下，结构风险定义如下：</p>
<script type="math/tex; mode=display">
R_{srm}(f)=\frac{1}{N}\sum_{i=1}^{N}L(y_i,f(x_i)) \tag{3}+\lambda J(f)</script><p>上式中：</p>
<p>$L(y_i,f(x_i))$ 表示损失函数；</p>
<p>$J(f)$ 为模型的复杂度，模型$f$越复杂，复杂度$J(f)$就越大​，也就是说复杂度表示了对复杂模型的惩罚（从而使得模型趋于精简）。</p>
<p>SRM由两部分组成：经验风险和VC置信范围，VC维反映了函数集的学习能力，VC维越大则学习机器越复杂。SRM模型对训练数据与未知的测试数据都有较好的预测。</p>
<p>结构风险最小化策略认为结构风险最小的模型是最优的模型，所以求解模型就是求解最优化问题：</p>
<script type="math/tex; mode=display">
\min_{f\in F}\frac{1}{N}\sum_{i=1}^{N}L(y_i,f(x_i))+\lambda J(f) \tag{4}</script><hr>
<p>人工神经网络，优化目标是基于经验风险最小化，容易陷入局部最优，一般需要大样本的训练来得到较优的结果；</p>
<p>支持向量机有着严格的理论和数学基础，基于结构风险最小化原则，泛化能力优于前者，算法具有全局最优解，对小样本有着很好的适用性。</p>
]]></content>
  </entry>
  <entry>
    <title>神经网络</title>
    <url>/2019/06/27/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Neural NetWorks</tag>
      </tags>
  </entry>
  <entry>
    <title>正则化</title>
    <url>/2019/06/27/%E6%AD%A3%E5%88%99%E5%8C%96/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Regularization</tag>
      </tags>
  </entry>
  <entry>
    <title>损失函数</title>
    <url>/2019/06/27/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Loss Function</tag>
      </tags>
  </entry>
  <entry>
    <title>欠拟合与过拟合</title>
    <url>/2019/06/27/%E6%AC%A0%E6%8B%9F%E5%90%88%E4%B8%8E%E8%BF%87%E6%8B%9F%E5%90%88/</url>
    <content><![CDATA[<p>一：</p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Overfitting</tag>
      </tags>
  </entry>
  <entry>
    <title>随机梯度下降</title>
    <url>/2019/06/27/%E9%9A%8F%E6%9C%BA%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>SGD</tag>
      </tags>
  </entry>
  <entry>
    <title>激活函数</title>
    <url>/2019/06/23/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h4 id="一：引入"><a href="#一：引入" class="headerlink" title="一：引入"></a><strong>一：引入</strong></h4><p>激活函数（activation function）用于对输入信息进行非线性变换，然后将变换后的输出信息作为输入信息传给下一层神经元，解决了线性模型表达能力不足的问题（如果没有非线性的激活函数，每一层节点的输入都是上一层输出的线性组合，线性函数容易解决，但是其复杂性有限，无法学习复杂类型的数据，而且无论网络有多少层，输出都是输入的线性组合）。</p>
<p>激活函数使反向传播成为可能，因为激活函数的误差梯度可以用来调整权重和偏差。如果没有可微的非线性函数，这就不可能实现。</p>
<a id="more"></a>
<p><img src="http://blog-009.test.upcdn.net/机器学习/Activation function 1.png" alt="图1 神经网络和它的数学模型"></p>
<p>为了更直观的理解为什么要引入激活函数，以如下的例子作以说明：</p>
<p>图2为一个单层的感知机，它的输出为一个线性方程，即函数图像为一条直线，可以用于线性可分的二分类问题：</p>
<p><img src="http://blog-009.test.upcdn.net/机器学习/Activation function 6.png" alt="图2 单层感知机示意图"></p>
<p>其输出为：</p>
<script type="math/tex; mode=display">
y=w_1x_1+w_2x_2+b</script><p>如果将其用于线性不可分的二分类情况呢？显然一条直线无法做到完全分开两类数据，但是为了能有更好的分类能力，我们试着将多个感知机组合起来，如下图所示：</p>
<p><img src="http://blog-009.test.upcdn.net/机器学习/Activation function 7.png" alt="图3 多个单层感知机的组合"></p>
<p>得到的最终输出为：</p>
<script type="math/tex; mode=display">
y=w_{211}(w_{111}x_1+w_{121}x_2+b_{11})\\\\
+w_{221}(w_{112}x_1+w_{122}x_2+b_{12})\\\\
+w_{231}(w_{113}x_1+w_{123}x_2+b_{13})</script><p>整理上式得到：</p>
<script type="math/tex; mode=display">
y=（w_{211}w_{111}+w_{221}w_{112}+w_{231}w_{113}）x_1\\\\
+(w_{211}w_{121}+w_{221}w_{122}+w_{231}w_{123})x_2\\\\
+(w_{211}b_{11}+w_{221}b_{12}+w_{231}b_{13})</script><p>从上式可以看出网络的输出结果是类似式单层感知机输出的线性方程，只不过是直线的位置和角度发生了变化而已。</p>
<p>再继续将网络加深，依然得到类似的结果。也就是说不管神经网络有多少层，它都会像单层网络一样工作，最终只能得到一个线性函数，而这根本不足解决线性不可分乃至更复杂的分类问题。</p>
<p>正是为了应对这一问题，在神经网络中引入了激活函数，非线性的激活函数使得输入到输出的映射变成非线性，从而能够学习和执行更复杂的任务。</p>
<p>如下图所示，在网络中添加一个非线性的激活函数：</p>
<p><img src="http://blog-009.test.upcdn.net/机器学习/Activation function 8.png" alt="图4 加入激活函数的单层感知机"></p>
<p>得到下的输出，很明显该输出是非线性的：</p>
<script type="math/tex; mode=display">
a=w_1x_1+w_2x_2+b</script><script type="math/tex; mode=display">
y=\sigma(a)</script><p>在图（3）的网络中加入非线性的激活函数后其示意图如图（5）所示：</p>
<p><img src="http://blog-009.test.upcdn.net/机器学习/Activation function 9.png" alt="图5 加入激活函数的组合感知机"></p>
<p>经过计算得到：</p>
<script type="math/tex; mode=display">
a_1=w_{111}x_1+w_{121}x_2+b_{11}\\\\
a_2=w_{112}x_1+w_{122}x_2+b_{12}\\\\
a_3=w_{113}x_1+w_{123}x_2+b_{13}</script><p>网络最终的输出为：</p>
<script type="math/tex; mode=display">
y=\sigma[(w_{211}\sigma(a_1))+(w_{221}\sigma(a_2))+(w_{231}\sigma(a_3))]</script><p>非线性激活函数的加入，解决了线性模型不能解决的问题。</p>
<p>常用的激活函数有Sigmoid激活函数，Tanh激活函数，ReLU激活函数以及ReLU的改进版本Leakey ReLU 和 ELU。</p>
<hr>
<h4 id="二：Sigmoid激活函数"><a href="#二：Sigmoid激活函数" class="headerlink" title="二：Sigmoid激活函数"></a><strong>二：Sigmoid激活函数</strong></h4><p>Sigmoid函数的表达式及图像如下所示：</p>
<script type="math/tex; mode=display">
Sigmoid(x)=\frac{1}{1+e^{-x}}</script><p><img src="http://blog-009.test.upcdn.net/机器学习/Activation function 2.jpg" alt="图6 Sigmoid与Tanh函数图像"></p>
<p>Sigmoid函数的输出映射在0到1区间，当神经元的输出为1时，表示该神经元完全被激活，否则为未被激活。</p>
<p>Sigmoid激活函数存在的问题是当神经元的激活状态接近0或者1时，这些区域的梯度会变的非常小接近于0，导致梯度消失，网络不能进行真正的学习。此外，该函数的另一个缺点是其图像并不关于原点对称。</p>
<hr>
<h4 id="三：Tanh激活函数"><a href="#三：Tanh激活函数" class="headerlink" title="三：Tanh激活函数"></a><strong>三：Tanh激活函数</strong></h4><p>Tanh函数是Sigmoid函数的一种变形，其图像被限制在两个水平线$y=-1$ 与$y=1$ 之间，如上图（6）所示。当神经元的输出为1时，表示该神经元完全被激活，否则为未被激活，函数表达式为：</p>
<script type="math/tex; mode=display">
Tanh(x)=\frac{e^x-e^{-x}}{e^x+e^{-x}}=2sigmoid(2x)-1</script><p>Tanh函数比Sigmoid函数优异的地方在于其图像关于原点对称，后续处理起来比较方便，而且相比sigmoid函数训练时收敛速度更快。</p>
<p>Tanh激活函数的缺点是也会像Sigmoid激活函数一样，会导致模型的梯度消失。</p>
<p>Tanh和Sigmoid作为激活函数两者的共同缺点在于都存在两端梯度弥散，计算量大的问题，而ReLU激活函数可以很好地解决这个问题。</p>
<hr>
<h4 id="四：ReLU激活函数"><a href="#四：ReLU激活函数" class="headerlink" title="四：ReLU激活函数"></a><strong>四：ReLU激活函数</strong></h4><p>ReLU函数的表达式和函数图像如下所示：</p>
<script type="math/tex; mode=display">
ReLU=max(0,x)</script><p><img src="http://blog-009.test.upcdn.net/机器学习/Activation function 3.bmp" alt="图7 ReLU函数图像"></p>
<p>ReLU激活函数梯度要么是1要么是0，有效的解决了梯度消失问题，此外ReLU激活函数（修正线性单元）优于其他激活函数的一点在于它不会同时激活所有的神经元，如果输入值是负的，ReLU函数会转换为0，而神经元不被激活。这意味着，在一段时间内，只有少量的神经元被激活，神经网络的这种稀疏性使其变得高效且易于计算。</p>
<p>ReLU激活函数的缺点是训练的时候比较“脆弱”，输入持续为负的神经元激活值总是为0，会导致部分神经元“死亡”。而Leaky ReLU与ELU解决了该问题，在输入小于0时，存在一个很小很小的斜率。</p>
<hr>
<h4 id="五：Leakey-ReLU-和-ELU激活函数"><a href="#五：Leakey-ReLU-和-ELU激活函数" class="headerlink" title="五：Leakey ReLU 和 ELU激活函数"></a><strong>五：Leakey ReLU 和 ELU激活函数</strong></h4><script type="math/tex; mode=display">
Leaky ReLU=max(0.01x,x)</script><p><img src="http://blog-009.test.upcdn.net/机器学习/Activation function 4.bmp" alt="图8 Leakey ReLU 函数图像"></p>
<p>Leakey ReLU激活函数与ReLU激活函数不同的是，在$x&lt;0$时，有一个很小但不为0的斜率，避免了神经元“死亡”。</p>
<script type="math/tex; mode=display">
ELU=\begin{cases}x\  \ x>0 \\\\ \alpha(e^x-1)\  \ others \end{cases}</script><p><img src="http://blog-009.test.upcdn.net/机器学习/Activation function 5.bmp" alt="图9 ELU函数图像"></p>
<p>理论上Leakey ReLU激活函数与ELU激活函数有ReLU激活函数所有的优点，但是实际应用中的较少，ELU的一个小缺点在于计算量稍大。</p>
<hr>
<h4 id="六：激活函数的选择"><a href="#六：激活函数的选择" class="headerlink" title="六：激活函数的选择"></a><strong>六：激活函数的选择</strong></h4><p>综合以上各激活函数的优缺点，一般优先选择ReLU激活函数，其次Tanh，最后Sigmoid激活函数。</p>
<p>注：ReLU函数只能在隐藏层中使用。</p>
<hr>
<h4 id="七：参考文献"><a href="#七：参考文献" class="headerlink" title="七：参考文献"></a><strong>七：参考文献</strong></h4><p><a href="https://zhuanlan.zhihu.com/p/45017091" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/45017091</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/30510596" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/30510596</a></p>
<p><a href="https://www.zhihu.com/question/22334626" target="_blank" rel="noopener">https://www.zhihu.com/question/22334626</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>activation function</tag>
      </tags>
  </entry>
  <entry>
    <title>AlexNet网络模型</title>
    <url>/2019/06/21/AlexNet%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h4 id="一：结构分析"><a href="#一：结构分析" class="headerlink" title="一：结构分析"></a><strong>一：结构分析</strong></h4><p>AlexNet网络结构示意图（双GPU并行运算）如下图所示，共由5个卷积层（convolution layer）和3个全连接层（fully-connected layer）共8层网络组成，输入图像尺寸为 227*227*3，经过5层的卷积操作和部分池化运算得到大小为 6*6*256 的特征图（feature map），最后通过全连接层输出 1000*1 的 特征向量。</p>
<p><img src="http://blog-009.test.upcdn.net/网络模型/AlexNet01.png" alt="AlexNet网络模型"></p>
<a id="more"></a>
<hr>
<p><strong>输入图像大小：</strong>227*227*3 （对原始的图像224*224*3 进行了Padding操作）</p>
<hr>
<p><strong>卷积层1：</strong></p>
<blockquote>
<p>​    输入数据：227*227*3 </p>
<p>​    卷积核：大小11*11*3  ，步长4，数量96</p>
<p>​    卷积后的数据：（227 - 11）/ 4 + 1 = 55 ，即 55*55*96 </p>
<p>​    ReLU1后的数据：55*55*96 </p>
<p>​    最大池化层1（Max Pooling）：核大小3*3，步长2</p>
<p>​    池化运算后的数据（降采样）：（55 -3 ）/ 2 + 1 = 27 ，即27*27*96 </p>
<p>​    局部响应归一化层（LRN）</p>
</blockquote>
<hr>
<p><strong>卷积层2：</strong></p>
<blockquote>
<p>​    输入数据：27*27*96 （需进行Padding操作）</p>
<p>​    卷积核：大小5*5*48，步长1，数量256</p>
<p>​    卷积后的数据：（27 + 4 - 5）/ 1 + 1 = 27，即27*27*256</p>
<p>​     ReLU2后的数据：27*27*256</p>
<p>​    局部响应归一化层（LRN）</p>
<p>​    最大池化层2：核大小3*3，步长2</p>
<p>​    池化运算后的数据（降采样）：（27 -3 ）/ 2 + 1 = 13 ，即13*13*256</p>
<p>​    局部响应归一化层（LRN）</p>
</blockquote>
<hr>
<p><strong>卷积层3：</strong></p>
<blockquote>
<p>​    输入数据：13*13*256（需进行Padding操作）</p>
<p>​    卷积核：大小3*3*128，步长1，数量384</p>
<p>​    卷积后的数据：（13 + 2 - 3）/ 1 + 1 = 13，即13*13*384</p>
<p>​     ReLU3后的数据：13*13*384</p>
<p>​    无LRN层和最大池化层</p>
</blockquote>
<hr>
<p><strong>卷积层4：</strong></p>
<blockquote>
<p>​    输入数据：13*13*384（需进行Padding操作）</p>
<p>​    卷积核：大小3*3*192，步长1，数量384</p>
<p>​    卷积后的数据：（13 + 2 - 3）/ 1 + 1 = 13，即13*13*384</p>
<p>​     ReLU4后的数据：13*13*384</p>
<p>​    无LRN层和最大池化层</p>
</blockquote>
<hr>
<p><strong>卷积层5：</strong></p>
<blockquote>
<p>​    输入数据：13*13*384（需进行Padding操作）</p>
<p>​    卷积核：大小3*3*192，步长1，数量256</p>
<p>​    卷积后的数据：（13 + 2 - 3）/ 1 + 1 = 13，即13*13*256</p>
<p>​     ReLU5后的数据：13*13*256</p>
<p>​    最大池化层：核大小3*3，步长2</p>
<p>​    池化运算后的数据（降采样）：（13 -3 ）/ 2 + 1 = 6 ，即6*6*256</p>
</blockquote>
<hr>
<p><strong>全连接层6：</strong></p>
<blockquote>
<p>​    输入数据：6*6*256</p>
<p>​    用4096个大小为 6*6*256 的卷积核对输入数据进行卷积操作，通过4096个神经元输出运算结果，4096个运算结果通过ReLU6生成4096个数据，再进行ReLU6激活函数和Dropout处理后输出4096个数据。</p>
</blockquote>
<hr>
<p><strong>全连接层7：</strong></p>
<blockquote>
<p>​    第6层输出的4096个数据与第7层的4096个神经元进行全连接，经由ReLU7进行处理后生成4096个数据，再进行Dropout处理后输出4096个数据。</p>
</blockquote>
<hr>
<p><strong>全连接层8：</strong></p>
<blockquote>
<p>​    第7层输出的4096个数据与第8层的1000个神经元进行全连接，输出1000*1的一维向量。最后用softmax输出1000类物体各类的概率值。</p>
</blockquote>
<hr>
<h4 id="二：主要特点"><a href="#二：主要特点" class="headerlink" title="二：主要特点"></a><strong>二：主要特点</strong></h4><p><strong>1. Training on Multiple GPUs</strong></p>
<p>利用两块NVIDIA GTX 580 3GB GPU并行运算来提高训练速度（通过120万张图像训练网络并训练了90轮，花费时间5到6天）。应用于所有卷积层和所有全连接层（GPU之间仅在特定的层间通信）。</p>
<p><strong>2. ReLU Nonlinearity（Rectified Linear Unit）</strong></p>
<p>使用ReLU激活函数代替了Sigmoid激活函数，并验证其效果在较深的网络超过了Sigmoid，解决了Sigmoid在网络较深时的梯度弥散问题。</p>
<p><strong>3. LRN（Local Response Normalization）</strong></p>
<p>LRN一般是在激活、池化后进行的一种处理方法，通过对局部神经元的活动创建竞争机制，使得其中响应比较大的值变得相对更大，并抑制其他反馈较小的神经元，增强了模型的泛化能力。AlexNet中LRN层应用于卷积层1、2后。</p>
<p><strong>4. Overlapping Pooling</strong></p>
<p>AlexNet全部采用最大池化而非此前普遍采用的平均池化，一方面避免了采用平均池化所导致的图像模糊，另一方面覆叠的池化操作（pool_size &gt; stride）使得特征信息更完善，在训练模型过程中更不容易过拟合。在AlexNet中最大池化操作应用于卷积层1、2、5后。</p>
<p><strong>5. Date Augmentation</strong></p>
<p>采用数据增强的方式扩充了数据库的同时避免过拟合。</p>
<p><strong>6. Dropout</strong></p>
<p>随机dropout一些神经元,以避免模型过拟合，在AlexNet网络模型中应用于全连接层6和全连接层7。</p>
<h4 id="三：学习细节"><a href="#三：学习细节" class="headerlink" title="三：学习细节"></a><strong>三：学习细节</strong></h4><p>使用随机梯度下降法（stochastic gradient descent ）进行训练，每个训练批次（batch size）有128个样本，动力（momentum）为0.9，权重衰减因子（weight decay factor）为0.0005。</p>
<h4 id="四：参考文献"><a href="#四：参考文献" class="headerlink" title="四：参考文献"></a><strong>四：参考文献</strong></h4><blockquote>
<p>1.原文：<a href="http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networ" target="_blank" rel="noopener">http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networ</a></p>
<p>2.原文翻译参考：<a href="https://blog.csdn.net/qq_39727487/article/details/88653215" target="_blank" rel="noopener">https://blog.csdn.net/qq_39727487/article/details/88653215</a></p>
<p>3.<a href="https://blog.csdn.net/qq_24695385/article/details/80368618" target="_blank" rel="noopener">https://blog.csdn.net/qq_24695385/article/details/80368618</a></p>
<p>4.<a href="https://blog.csdn.net/zyqdragon/article/details/72353420" target="_blank" rel="noopener">https://blog.csdn.net/zyqdragon/article/details/72353420</a></p>
<p>5.<a href="https://link.zhihu.com/?target=http%3A//www.cs.toronto.edu/~fritz/absps/imagenet.pdf" target="_blank" rel="noopener">https://link.zhihu.com/?target=http%3A//www.cs.toronto.edu/~fritz/absps/imagenet.pdf</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Netwaork Model</category>
      </categories>
      <tags>
        <tag>AlexNet</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV-Python 绘图基本操作</title>
    <url>/2019/06/21/OpenCV-Python-%E7%BB%98%E5%9B%BE%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h4 id="一、直线的绘制"><a href="#一、直线的绘制" class="headerlink" title="一、直线的绘制"></a><strong>一、直线的绘制</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import cv2 as cv</span><br><span class="line"></span><br><span class="line">img = np.zeros((512,512,3), np.uint8)    # 画布大小512*512，空白</span><br><span class="line"></span><br><span class="line">cv.line(img,(0,0),(511,511),(255,0,0),5) # 第一条直线，宽度5px</span><br><span class="line">cv.line(img,(0,511),(511,0),(0,255,0),5) # 第二条直线 宽度5px</span><br><span class="line"></span><br><span class="line">cv.imshow(&apos;image&apos;, img)</span><br><span class="line"></span><br><span class="line">k = cv.waitKey(0)</span><br><span class="line">if k == 27:</span><br><span class="line">    cv.destroyAllWindows()</span><br><span class="line">elif k == ord(&apos;s&apos;):</span><br><span class="line">    cv.imwrite(&apos;line.png&apos;,img)</span><br><span class="line">    cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="二、矩形的绘制"><a href="#二、矩形的绘制" class="headerlink" title="二、矩形的绘制"></a><strong>二、矩形的绘制</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cv.rectangle(img,(206,206),(306,306),(255,0,0),5)</span><br></pre></td></tr></table></figure>
<h4 id="三、圆的绘制"><a href="#三、圆的绘制" class="headerlink" title="三、圆的绘制"></a><strong>三、圆的绘制</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cv.circle(img,(256,256), 100, (0,0,255))      # 圆形，线宽1px</span><br><span class="line">cv.circle(img,(256,256), 100, (0,0,255), -1)  # 填充的圆</span><br></pre></td></tr></table></figure>
<h4 id="四、椭圆的绘制"><a href="#四、椭圆的绘制" class="headerlink" title="四、椭圆的绘制"></a><strong>四、椭圆的绘制</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cv.ellipse(img,(256,256),(100,50),0,0,360,(255,0,0),5)</span><br></pre></td></tr></table></figure>
<p><img src="http://blog-009.test.upcdn.net//01-17:27:37.png" alt></p>
<h4 id="五、多边形的绘制"><a href="#五、多边形的绘制" class="headerlink" title="五、多边形的绘制"></a><strong>五、多边形的绘制</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pts = np.array([[10,5],[20,30],[70,20],[50,10]], np.int32)</span><br><span class="line">pts = pts.reshape((-1,1,2))</span><br><span class="line">cv.polylines(img,[pts],True,(255,0,0))</span><br></pre></td></tr></table></figure>
<p>绘制多边形先指定多边形各个顶点的坐标，</p>
<p>第三行第三个参数为False时，则绘制出一些列多边形的顶点而非闭合图形。</p>
<h4 id="六、图像中文字的添加"><a href="#六、图像中文字的添加" class="headerlink" title="六、图像中文字的添加"></a><strong>六、图像中文字的添加</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">font = cv.FONT_HERSHEY_SIMPLEX  # 字体</span><br><span class="line">cv.putText(img,&apos;OpenCV&apos;,(10,500), font, 4,(255,255,255),2,cv.LINE_AA)</span><br><span class="line"># 字体大小为4，线型为cv.LINE_AA</span><br></pre></td></tr></table></figure>
<h4 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a><strong>参考文献：</strong></h4><blockquote>
<p><a href="https://docs.opencv.org/3.4.0/dc/da5/tutorial_py_drawing_functions.html" target="_blank" rel="noopener">https://docs.opencv.org/3.4.0/dc/da5/tutorial_py_drawing_functions.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
  </entry>
  <entry>
    <title>OpenCV-Python 视频的基本操作</title>
    <url>/2019/06/21/OpenCV-Python-%E8%A7%86%E9%A2%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h4 id="一、Capture-Video-from-camera"><a href="#一、Capture-Video-from-camera" class="headerlink" title="一、Capture Video from camera"></a><strong>一、Capture Video from camera</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import cv2 as cv</span><br><span class="line"></span><br><span class="line">cap = cv.VideoCapture(0)</span><br><span class="line">while(True):</span><br><span class="line">    ret, frame = cap.read() #从摄像头读取图片</span><br><span class="line">    gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY) # 转为灰度图</span><br><span class="line">    cv.imshow(&apos;frame&apos;,gray) # 显示图像</span><br><span class="line">    k = cv.waitKey(0)</span><br><span class="line">    if k == 27:             # 按ESC键推出摄像</span><br><span class="line">        cv.destroyAllWindows()</span><br><span class="line">        break</span><br><span class="line">    elif k == ord(&quot;s&quot;):     # 按S键保存图像</span><br><span class="line">        cv.imwrite(&quot;image2.jpg&quot;,frame)</span><br><span class="line">        cv.destroyAllWindows()</span><br><span class="line">        break</span><br><span class="line">cap.release() # 关闭摄像头</span><br></pre></td></tr></table></figure>
<p>注：ESC的ASCLL码为27。</p>
<a id="more"></a>
<h4 id="二、Playing-Video-from-file"><a href="#二、Playing-Video-from-file" class="headerlink" title="二、Playing Video from file"></a><strong>二、Playing Video from file</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import cv2 as cv</span><br><span class="line"></span><br><span class="line">cap = cv.VideoCapture(&quot;test.mp4&quot;)</span><br><span class="line"></span><br><span class="line">while(cap.isOpened()):</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)</span><br><span class="line">    cv.imshow(&apos;frame&apos;,gray)</span><br><span class="line">    if cv.waitKey(1) &amp; 0xFF == ord(&apos;q&apos;):</span><br><span class="line">        break</span><br><span class="line">cap.release()</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h4 id="三、Saving-a-Video"><a href="#三、Saving-a-Video" class="headerlink" title="三、Saving a Video"></a><strong>三、Saving a Video</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import cv2 as cv</span><br><span class="line"></span><br><span class="line">cap = cv.VideoCapture(0)</span><br><span class="line">fourcc = cv.VideoWriter_fourcc(*&apos;XVID&apos;) #编码解码形式</span><br><span class="line">out = cv.VideoWriter(&apos;output.avi&apos;,fourcc, 20.0, (640,480))</span><br><span class="line">while(cap.isOpened()):</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    if ret==True:</span><br><span class="line">        frame = cv.flip(frame,0)</span><br><span class="line">        out.write(frame)</span><br><span class="line">        cv.imshow(&apos;frame&apos;,frame)</span><br><span class="line">        if cv.waitKey(1) &amp; 0xFF == ord(&apos;q&apos;):</span><br><span class="line">            break</span><br><span class="line">    else:</span><br><span class="line">        break</span><br><span class="line">cap.release()</span><br><span class="line">out.release()</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p>FourCC ：用以指定视频编码解码方式，其所有的格式及描述：<a href="https://blog.csdn.net/u013943420/article/details/78779197" target="_blank" rel="noopener">here</a></p>
<p>XVID：一个开放源代码的MPEG-4的视频编解码器，文件扩展名可以是avi、mkv、mp4等；</p>
<p>FPS（Frame Per-Second，每秒传输的帧数）：通常电影为24帧，电视30帧。</p>
<p>cv.waitKey(1)：表示延时1ms，即显示一帧然后等待1毫秒再显示下一帧。</p>
<h4 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a><strong>参考文献：</strong></h4><blockquote>
<p><a href="https://docs.opencv.org/3.4.0/dd/d43/tutorial_py_video_display.html" target="_blank" rel="noopener">https://docs.opencv.org/3.4.0/dd/d43/tutorial_py_video_display.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
  </entry>
  <entry>
    <title>OpenCV-Python 图像的基本操作</title>
    <url>/2019/06/21/OpenCV-Python-%E5%9B%BE%E5%83%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%C2%83/</url>
    <content><![CDATA[<ul>
<li><strong>cv.imread()</strong> : 读取图像</li>
<li><strong>cv.imshow()</strong> : 显示图像</li>
<li><strong>cv.imwrite()</strong> : 保存图像</li>
</ul>
<a id="more"></a>
<h4 id="一、图像的读取和显示"><a href="#一、图像的读取和显示" class="headerlink" title="一、图像的读取和显示"></a><strong>一、图像的读取和显示</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import cv2 as cv</span><br><span class="line"></span><br><span class="line">img = cv.imread(&apos;test.jpg&apos;,0)     # 以灰度模式读取图像，0为灰度模式，1为彩色模式</span><br><span class="line"></span><br><span class="line">cv.imshow(&apos;image&apos;,img)            # 显示图像，“image”和“img”分别为窗口和图片的名称，</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()            # 删除窗口</span><br></pre></td></tr></table></figure>
<p>删除指定窗口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cv.destroyWindow(&quot;image&quot;)</span><br></pre></td></tr></table></figure>
<p>cv.waitKey(0)：表示程序无限期等待，直到用户触发任意键。</p>
<h4 id="二、读取并更改图像名称及格式"><a href="#二、读取并更改图像名称及格式" class="headerlink" title="二、读取并更改图像名称及格式"></a><strong>二、读取并更改图像名称及格式</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import cv2 as cv</span><br><span class="line"></span><br><span class="line">img = cv.imread(&apos;test.jpg&apos;,0)</span><br><span class="line"></span><br><span class="line">cv.imwrite(&apos;test01.png&apos;,img)      # 以名为test01格式为png保存图像</span><br></pre></td></tr></table></figure>
<h4 id="三、用Matplotlib读取并显示图像"><a href="#三、用Matplotlib读取并显示图像" class="headerlink" title="三、用Matplotlib读取并显示图像"></a><strong>三、用Matplotlib读取并显示图像</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import cv2 as cv</span><br><span class="line">from matplotlib import pyplot as plt</span><br><span class="line"></span><br><span class="line">img = cv.imread(&apos;test.jpg&apos;,0)</span><br><span class="line">plt.imshow(img, cmap = &apos;gray&apos;, interpolation = &apos;bicubic&apos;)</span><br><span class="line">plt.xticks([]), plt.yticks([])  # 隐藏X与Y轴</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><strong>Warning：</strong>如果用OpenCV读取RGB模式的彩色图像，则无法在Matplotlib正常显示（OpenCV加载的彩色图像为BGR模式）。</p>
<h4 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a><strong>参考文献：</strong></h4><blockquote>
<p><a href="https://docs.opencv.org/3.4.0/dc/d2e/tutorial_py_image_display.html" target="_blank" rel="noopener">https://docs.opencv.org/3.4.0/dc/d2e/tutorial_py_image_display.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
  </entry>
  <entry>
    <title>用you-get进行网页视频的下载</title>
    <url>/2019/06/19/%E7%94%A8you-get%E8%BF%9B%E8%A1%8C%E7%BD%91%E9%A1%B5%E8%A7%86%E9%A2%91%E7%9A%84%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<p>You-Get是一个命令行程序，提供便利的方式来下载网络上的媒体信息，可以是视频，音乐或者图片。</p>
<a id="more"></a>
<h4 id="一：You-get的安装"><a href="#一：You-get的安装" class="headerlink" title="一：You-get的安装"></a><strong>一：You-get的安装</strong></h4><ol>
<li><p>在windows命令控制窗口中输入如下指令进行You-get的安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install you-get</span><br></pre></td></tr></table></figure>
</li>
<li><p>You-get工具的升级：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install --upgrade you-get</span><br></pre></td></tr></table></figure>
</li>
<li><p>pip的更新：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -m pip install --upgrade pip</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="二：视频的下载"><a href="#二：视频的下载" class="headerlink" title="二：视频的下载"></a><strong>二：视频的下载</strong></h4><ol>
<li><p>画质的选择：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">you-get -i 视频链接</span><br></pre></td></tr></table></figure>
<p>在cmd命令控制窗口中输入上述指令后，将会出现一系列视频画质选项及其相应的下载指令，如下图所示：</p>
<p><img src="http://blog-009.test.upcdn.net//you-get.png" alt="画质及格式的查看"></p>
</li>
<li><p>视频的下载：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">you-get -i --format=mp4hd URL</span><br></pre></td></tr></table></figure>
<p>将上述指令中的 URL 替换成所要下载的视频链接即可（具体画质和下载格式见指令）</p>
</li>
</ol>
<h4 id="三：暂停下载"><a href="#三：暂停下载" class="headerlink" title="三：暂停下载"></a><strong>三：暂停下载</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ctrl+C</span><br></pre></td></tr></table></figure>
<h4 id="四：支持的部分国内网站"><a href="#四：支持的部分国内网站" class="headerlink" title="四：支持的部分国内网站"></a><strong>四：支持的部分国内网站</strong></h4><ol>
<li>哔哩哔哩（<a href="http://www.bilibili.com/" target="_blank" rel="noopener">http://www.bilibili.com/</a>）</li>
<li>爱奇艺（<a href="http://www.iqiyi.com/" target="_blank" rel="noopener">http://www.iqiyi.com/</a>）</li>
<li>优酷（<a href="http://www.youku.com/" target="_blank" rel="noopener">http://www.youku.com/</a>）</li>
<li>腾讯视频（<a href="http://v.qq.com/" target="_blank" rel="noopener">http://v.qq.com/</a>）</li>
<li>凤凰视频（<a href="http://v.ifeng.com/" target="_blank" rel="noopener">http://v.ifeng.com/</a>）</li>
<li>乐视网（<a href="http://www.letv.com/" target="_blank" rel="noopener">http://www.letv.com/</a>）</li>
<li>知乎（<a href="https://www.zhihu.com/）" target="_blank" rel="noopener">https://www.zhihu.com/）</a></li>
<li>豆瓣（<a href="http://www.douban.com/" target="_blank" rel="noopener">http://www.douban.com/</a>）</li>
</ol>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h4><p><a href="https://you-get.org/" target="_blank" rel="noopener">https://you-get.org/</a></p>
<p><a href="https://github.com/soimort/you-get/wiki/中文说明" target="_blank" rel="noopener">https://github.com/soimort/you-get/wiki/中文说明</a></p>
]]></content>
  </entry>
  <entry>
    <title>Ubuntu18.04上OpenCV3.4.0的安装和测试</title>
    <url>/2019/05/03/Ubuntu18-04%E4%B8%8AOpenCV3-4-0%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>Ubuntu上OpenCV的安装由于要安装各种依赖，而且编译过程稍有不慎便会遇到各种意外状况，导致安装的难度较大，为此我也是参考了很多资料安装了很多次才安装并且测试成功。此文记录了安装的详细过程，希望能为同样需要搭建 OpenCV 环境却在安装过程中遇到各种棘手问题的人提供一些有益的参考。</p>
<h4 id="一、OpenCV3-4-0安装包的下载"><a href="#一、OpenCV3-4-0安装包的下载" class="headerlink" title="一、OpenCV3.4.0安装包的下载"></a>一、OpenCV3.4.0安装包的下载</h4><p><a href="https://opencv.org/releases/page/2/" target="_blank" rel="noopener">下载地址</a> （选择Sources项下载保存到本地）</p>
<p>我是在主目录位置新建了一个名为 “Software” 的文件夹，并将下载的 opencv-3.4.0 解压在此目录下。</p>
<p><img src="http://blog-009.test.upcdn.net//cv01.png" alt></p>
<a id="more"></a>
<h4 id="二、Ubuntu上修改默认启动的Python版本"><a href="#二、Ubuntu上修改默认启动的Python版本" class="headerlink" title="二、Ubuntu上修改默认启动的Python版本"></a>二、Ubuntu上修改默认启动的Python版本</h4><p>由于学习过程中很多资源的代码都是建立在Python3的基础上，然而一般的OpenCV安装如果不做配置会默认指向Ubuntu系统默认的Python2.7版本，这就导致了在Python3环境中调用OpenCV时会出现 “No module named cv2” 这种错误。</p>
<p>为了解决这个问题，有必要将Ubuntu18.04中默认的Python2.7启动版本修改为Python3.6版本（Ubuntu18.04中默认安装了两个 Python 版本：Python 2.7.15 和 Python 3.6.7）</p>
<p>修改方法为：</p>
<p>移除 /usr/bin 目录下指向 Python2 的软链接（该目录下有一个名为 “python” 的文件，移除之），并与Python3.6建立新的链接（不要删除安装的Python2.7版本，否则可能后果很严重）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rm /usr/bin/python</span><br><span class="line">sudo ln -s /usr/local/bin/python3.6 /usr/bin/python</span><br></pre></td></tr></table></figure>
<p>上述 /usr/local/bin/python3.6 是 Python 3.6.7 的安装位置，执行第二条指令后将会在 /usr/bin 目录下重新生成一个名为 “python” 的文件, 再于终端输入 python 时，将会默认启动Python 3.6 版本。</p>
<h4 id="三、OpenCV相关依赖安装"><a href="#三、OpenCV相关依赖安装" class="headerlink" title="三、OpenCV相关依赖安装"></a>三、OpenCV相关依赖安装</h4><ol>
<li>软件列表及软件的更新</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>
<ol>
<li>开发工具的安装</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential cmake pkg-config</span><br></pre></td></tr></table></figure>
<ol>
<li>图像处理相关库安装</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libjpeg8-dev libtiff5-dev libjasper-dev libpng12-dev</span><br></pre></td></tr></table></figure>
<p>libjpeg8-dev、libtiff5-dev、libpng12-dev可能存在新的版本，可用如下的指令进行升级：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libjpeg8-dev</span><br><span class="line">sudo apt-get install libtiff-dev</span><br><span class="line">sudo apt-get install libpng-dev</span><br></pre></td></tr></table></figure>
<ol>
<li>视频处理相关库安装</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev</span><br><span class="line">sudo apt-get install libxvidcore-dev libx264-dev</span><br></pre></td></tr></table></figure>
<ol>
<li>GTK库的安装</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libgtk-3-dev</span><br></pre></td></tr></table></figure>
<ol>
<li>用于优化opencv内部各种功能的库的安装</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libatlas-base-dev gfortran</span><br></pre></td></tr></table></figure>
<ol>
<li>numpy库的安装</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python3-numpy</span><br></pre></td></tr></table></figure>
<h4 id="四、编译及安装"><a href="#四、编译及安装" class="headerlink" title="四、编译及安装"></a>四、编译及安装</h4><ol>
<li>进入已解压的文件opencv-3.4.0目录下，执行如下指令：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -D CMAKE_BUILD_TYPE=RELEASE \</span><br><span class="line">-D CMAKE_INSTALL_PREFIX=/usr/local \</span><br><span class="line">-D PYTHON3_EXECUTABLE=/usr/bin/python3 \</span><br><span class="line">-D PYTHON_INCLUDE_DIR=/usr/include/python3.6 \</span><br><span class="line">-D PYTHON_LIBRARY=/usr/lib/x86_64-linux-gnu/libpython3.6m.so \</span><br><span class="line">-D PYTHON3_NUMPY_INCLUDE_DIRS=/usr/local/lib/python3.6/dist-packages/numpy/core/include \</span><br><span class="line">-D INSTALL_PYTHON_EXAMPLES=ON \</span><br><span class="line">-D INSTALL_C_EXAMPLES=OFF \</span><br><span class="line">-D PYTHON_EXECUTABLE=/usr/lib/python3 \</span><br><span class="line">-D BUILD_EXAMPLES=ON ..</span><br></pre></td></tr></table></figure>
<p>运行完成后会出现如下的信息，可以看到 Python(for build)          /usr/bin/python3 这一项。</p>
<p><img src="http://blog-009.test.upcdn.net//cv02.png" alt></p>
<ol>
<li>编译</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make -j4</span><br></pre></td></tr></table></figure>
<p>编译过程比较漫长，完成后如下图所示：</p>
<p><img src="http://blog-009.test.upcdn.net//cv03.png" alt></p>
<ol>
<li>安装</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>如果不出什么意外，安装的过程将会比较顺利，完成后会如下图所示：</p>
<p><img src="http://blog-009.test.upcdn.net//cv04.png" alt></p>
<h4 id="五、安装成功与否的测试"><a href="#五、安装成功与否的测试" class="headerlink" title="五、安装成功与否的测试"></a>五、安装成功与否的测试</h4><ol>
<li>首先在终端输入：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line">import cv2</span><br></pre></td></tr></table></figure>
<p>如果没有提示任何错误，接下来用HOG特征的提取代码做一下测试：</p>
<ol>
<li>HOG特征提取的测试</li>
</ol>
<p>测试图片为：</p>
<p><img src="http://blog-009.test.upcdn.net//test.jpg" alt></p>
<p>将该图片下载并重命名为 “test”，临时放在根目录下。</p>
<p>HOG特征提取代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from skimage.feature import hog</span><br><span class="line">from skimage import io</span><br><span class="line">from PIL import Image</span><br><span class="line">import cv2</span><br><span class="line"></span><br><span class="line">img = cv2.cvtColor(cv2.imread(&apos;/home/suyuan/test.jpg&apos;), cv2.COLOR_BGR2GRAY)</span><br><span class="line">print(img.shape)</span><br><span class="line">normalised_blocks, hog_image = hog(img, orientations=9, pixels_per_cell=(8, 8), cells_per_block=(2, 2), block_norm=&apos;L2-Hys&apos;,visualise=True)</span><br><span class="line">io.imshow(hog_image)</span><br><span class="line">io.show()</span><br></pre></td></tr></table></figure>
<p>将该代码复制下来并保存为名为 test 的 .py 格式文件，与测试图片放在同一目录下。</p>
<p>在终端输入如下的指令进行HOG特征提取所需要的 skimage 库的安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python3-skimage</span><br></pre></td></tr></table></figure>
<p>安装好skimage库后，在终端运行HOG特征提取代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python test.py</span><br></pre></td></tr></table></figure>
<p>此时不出意外的话，会跳出如下一张HOG特征图，说明OpenCV安装成功。</p>
<p><img src="http://blog-009.test.upcdn.net//cv05.png" alt></p>
<p>本文的安装方法只能说明照这样安装可以安装成功，并不代表一定得这样安装，OpenCV安装成功与否的测试也可以选择其他较为简单且直观的方法，。</p>
<h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><blockquote>
<p><a href="https://www.jianshu.com/p/2975af275871" target="_blank" rel="noopener">https://www.jianshu.com/p/2975af275871</a></p>
<p><a href="https://www.pyimagesearch.com/2016/10/24/ubuntu-16-04-how-to-install-opencv/" target="_blank" rel="noopener">https://www.pyimagesearch.com/2016/10/24/ubuntu-16-04-how-to-install-opencv/</a></p>
<p><a href="https://blog.csdn.net/lch_vison/article/details/79112693" target="_blank" rel="noopener">https://blog.csdn.net/lch_vison/article/details/79112693</a></p>
<p><a href="https://blog.csdn.net/u013066730/article/details/79411767" target="_blank" rel="noopener">https://blog.csdn.net/u013066730/article/details/79411767</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu18.04上修改默认启动的python版本</title>
    <url>/2019/05/03/%C2%96Ubuntu18-04%E4%B8%8A%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E5%90%AF%E5%8A%A8%E7%9A%84python%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<p>Ubuntu18.04中默认安装了两个 Python 版本：Python 2.7.15 和 Python 3.6.7 ，在命令终端输入 python 时，默认的启动版本是 python 2.7.15 ，通过以下两种方式可以将默认启动的 Python 版本修改为 3.6.7 ：</p>
<h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><p>直接在终端执行以下两条命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/python python /usr/bin/python2 100</span><br><span class="line">sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 150</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><p>移除 /usr/bin 目录下指向 Python2 的软链接（该目录下有一个名为 “python” 的文件，移除之）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rm /usr/bin/python</span><br><span class="line">sudo ln -s /usr/local/bin/python3.6 /usr/bin/python</span><br></pre></td></tr></table></figure>
<p>上述 /usr/local/bin/python3.6 是 Python 3.6.7 的安装位置，执行第二条指令后将会在 /usr/bin 目录下重新生成一个名为 “python” 的文件, 再于终端输入 python 时，将会默认启动Python 3.6 版本。</p>
<p>Python安装位置的查询方法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">whereis python</span><br></pre></td></tr></table></figure>
<p><strong>注意：请勿删除python2.7版本。</strong></p>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu18.04上WPS2019的安装</title>
    <url>/2019/04/30/Ubuntu18-04%E4%B8%8AWPS2019%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h4 id="一、WPS安装包的下载"><a href="#一、WPS安装包的下载" class="headerlink" title="一、WPS安装包的下载"></a>一、WPS安装包的下载</h4><p>在 <a href="https://www.wps.cn/product/wpslinux/#" target="_blank" rel="noopener">WPS官网</a> 下载 WPS Office 2019 For Linux 的 Deb 格式安装包：</p>
<p><img src="http://blog-009.test.upcdn.net//wps01.png" alt="图1 安装包下载"></p>
<h4 id="二、将下载的安装包右键用“软件安装“打开并安装，或者终端输入如下指令进行安装："><a href="#二、将下载的安装包右键用“软件安装“打开并安装，或者终端输入如下指令进行安装：" class="headerlink" title="二、将下载的安装包右键用“软件安装“打开并安装，或者终端输入如下指令进行安装："></a>二、将下载的安装包右键用“软件安装“打开并安装，或者终端输入如下指令进行安装：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i wps-office_11.1.0.8392_amd64.deb</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="三、修复字体缺失"><a href="#三、修复字体缺失" class="headerlink" title="三、修复字体缺失"></a>三、修复字体缺失</h4><p>安装好的WPS在第一次打开时，会提示系统缺失字体。</p>
<p>下载 <a href="https://pan.baidu.com/s/1mh0lcbY" target="_blank" rel="noopener">字体包</a> 并解压，运行如下的命令将解压后的字体文件移至 <code>/usr/share/fonts</code> 目录下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo su</span><br><span class="line">sudo mv /home/suyuan/下载/wps_symbol_fonts/ /usr/share/fonts/</span><br></pre></td></tr></table></figure>
<p>之后运行以下指令生成字体的索引信息以及更新字体的缓存：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /usr/share/fonts</span><br><span class="line">sudo mkfontscale</span><br><span class="line">sudo mkfontdir</span><br><span class="line">sudo fc-cache</span><br></pre></td></tr></table></figure>
<h4 id="四、Libreoffice-的卸载"><a href="#四、Libreoffice-的卸载" class="headerlink" title="四、Libreoffice 的卸载"></a>四、Libreoffice 的卸载</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove libreoffice-common</span><br></pre></td></tr></table></figure>
<p>或者进入软件管理中心进行卸载。</p>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu18.04关机卡死的解决方法</title>
    <url>/2019/04/30/Ubuntu18-04%E5%85%B3%E6%9C%BA%E5%8D%A1%E6%AD%BB%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>联想拯救者R720因为带有独立显卡，在安装Win10/Ubuntu18.04双系统时大概率上会遇到Ubuntu系统关机或者关机重启电脑时就卡死的情况。解决方法如下：</p>
<p>在终端输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">software-properties-gtk</span><br></pre></td></tr></table></figure>
<p>会弹出如下的 “软件和更新” 窗口：</p>
<a id="more"></a> 
<p><img src="http://blog-009.test.upcdn.net//$001.png" alt></p>
<p>选择菜单栏的 “附加驱动” ，会出现带有你自己电脑显卡型号的一个选择项，选择该项并 “应用更改”，电脑即可正常关机和重启。</p>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu18.04上Github的安装</title>
    <url>/2019/04/30/Ubuntu18-04%E4%B8%8AGithub%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>git 安装前，需先进行 Github 账号的注册。</p>
<h4 id="一、Git-的安装"><a href="#一、Git-的安装" class="headerlink" title="一、Git 的安装"></a>一、Git 的安装</h4><p>在 Ubuntu 命令终端输入如下指令进行 git 的安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install git</span><br></pre></td></tr></table></figure>
<p>根据提示输入管理员密码，之后询问是否安装，输入 “y” 即可。</p>
<a id="more"></a>
<p><img src="http://blog-009.test.upcdn.net//gitaz01.png" alt="图1 git 的安装"></p>
<p> 接下来进行用户名和密码的配置</p>
<p>在命令终端依次输入如下的指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;此处填入注册的github用户名&quot;</span><br><span class="line">git config --global user.email &quot;此处填入注册github时的邮箱&quot;</span><br></pre></td></tr></table></figure>
<p>user.name 后边填入注册的 github 用户名；user.email 后边填入注册 github 时的邮箱。</p>
<p>再次输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure>
<p>将会显示注册 github 时的用户名和邮箱地址。</p>
<p><img src="http://blog-009.test.upcdn.net//gitaz02.png" alt="图2 用户名和密码的配置"></p>
<h4 id="二、SSH-Keys-的添加"><a href="#二、SSH-Keys-的添加" class="headerlink" title="二、SSH Keys 的添加"></a>二、SSH Keys 的添加</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;注册邮箱&quot;  # 此处填入注册邮箱</span><br></pre></td></tr></table></figure>
<p><img src="http://blog-009.test.upcdn.net//gitaz03.png" alt="图3 SSH Keys的生成"></p>
<p>上述指令执行过程中连续回车即可，key 的默认保存位置为 /.ssh 目录，接下来转到该目录下，并输入如下的指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /home/suyuan/.ssh</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>
<p>会出现 id_rsa  id_rsa.pub , 接着输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>将会生成所需的一串公钥：</p>
<p><img src="http://blog-009.test.upcdn.net//gitaz04.png" alt="图4 公钥"></p>
<p>将该公钥进行备份，接下来登陆自己的 github 账号，点击自己头像处的小三角，在下拉菜单中找到 “Settings” ，进去后选择 “SSH and GPG keys” 这一项，之后点击 “New SSH key” 新建一个 SSH key。</p>
<p><img src="http://blog-009.test.upcdn.net//$009.png" alt="图5 SSH key 的创建"></p>
<p>在 “ Title ” 处随意填写一个名称；</p>
<p>在 “ Key ” 处，将刚才生成的一串公钥复制进去并保存。</p>
<p>返回根目录，输入如下指令测试密钥是否配置成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /                       # 返回根目录</span><br><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>出现 “ You’ve successfully authenticated, but GitHub does not provide shell access. ” 等字样时，说明配置成功。</p>
<p><img src="http://blog-009.test.upcdn.net//gitaz06.png" alt="图6 密钥配置成功与否的验证"></p>
<h4 id="三、远程仓库的创建"><a href="#三、远程仓库的创建" class="headerlink" title="三、远程仓库的创建"></a>三、远程仓库的创建</h4><p>点击自己 Github 头像左边的 “+” ，选择 “New Repository” 新建一个远程仓库，创建完成后，会生成一个如下所示的网页，HTTPS SSH 后面的那个网址保存下来以备创建本地仓库时用。</p>
<p><img src="http://blog-009.test.upcdn.net//gitaz07.png" alt="图7 远程仓库的创建"></p>
<h4 id="四、本地仓库的创建"><a href="#四、本地仓库的创建" class="headerlink" title="四、本地仓库的创建"></a>四、本地仓库的创建</h4><p>在命令终端输入如下指令进行远程仓库的克隆和初始化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone &quot;此处复制进上述保存的那个网址&quot;</span><br></pre></td></tr></table></figure>
<p>此时会在根目录下生成一个与远程仓库同名的文件夹，例如我所创建的仓库名称为 “github” 。</p>
<p>转至所生成的本地仓库目录下，将仓库初始化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd “本地仓库名”</span><br><span class="line">git init</span><br></pre></td></tr></table></figure>
<p><img src="http://blog-009.test.upcdn.net//gitaz08.png" alt="图8 本地仓库初始化"></p>
<h4 id="五、将本地仓库文件推送至远程仓库"><a href="#五、将本地仓库文件推送至远程仓库" class="headerlink" title="五、将本地仓库文件推送至远程仓库"></a>五、将本地仓库文件推送至远程仓库</h4><p>在本地仓库新建一个名为 “ceshi” 的文本，执行如下的指令将该文件即可推送至远程仓库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add ceshi</span><br><span class="line">git commit -m &quot;first commit&quot;  # 提交说明</span><br><span class="line">git remote add origin https: https//github.com/Xavier01/github.git # 仓库地址</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<p><img src="http://blog-009.test.upcdn.net//gitaz09.png" alt="图9 本地文件的提交"></p>
<p>登陆Github 账号，在所创建的仓库中，即可看到从本地提交的文件及其信息。</p>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo-网站分析插件配置</title>
    <url>/2019/04/24/Hexo-%E7%BD%91%E7%AB%99%E5%88%86%E6%9E%90%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>为了统计博客的访问量等信息，需要安装并配置相关网站分析插件，ICRUS主题提供了四种分析插件：谷歌分析（Google Analytics）、百度分析(Baidu Analytics)、Hotjar 以及不蒜子(Busuanzi)。</p>
<p><strong>不蒜子：两行代码搞定计数</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>由于不蒜子可永久免费使用，且已经在ICRAUS中配置好了，只需打开 “使用开关” 即可，具体方法为在主题的配置文件 <code>_config.yml</code> 中找到 “busuanzi” 关键字，然后将其后默认的 “false” 修改为 “true” ，保存并重新部署即会在博客底部显示访客量，之后也可随时关闭统计。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># https://busuanzi.ibruce.info     </span><br><span class="line">busuanzi: ture                        # 修改此项</span><br></pre></td></tr></table></figure>
<p><strong>更多信息可参考：</strong></p>
<ol>
<li>不蒜子官网: <a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">http://busuanzi.ibruce.info/</a></li>
<li>ICARUS主题官网：<a href="https://blog.zhangruipeng.me/hexo-theme-icarus/" target="_blank" rel="noopener">https://blog.zhangruipeng.me/hexo-theme-icarus/</a></li>
<li>幽小鬼简书：<a href="https://www.jianshu.com/p/c311d31265e0" target="_blank" rel="noopener">https://www.jianshu.com/p/c311d31265e0</a></li>
</ol>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>ICARUS</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-About 页面的添加</title>
    <url>/2019/04/23/Hexo-About-%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%B7%BB%E5%8A%A0/</url>
    <content><![CDATA[<p>ICARUS主题不经配置的 “About” 菜单在访问时，会转至 404 页面，为了在 “About” 链接页面中添加个人简介及相关信息时，应进行相应的配置！</p>
<a id="more"></a>
<h2 id="一：ICARUS主题配置文件的更改"><a href="#一：ICARUS主题配置文件的更改" class="headerlink" title="一：ICARUS主题配置文件的更改"></a>一：ICARUS主题配置文件的更改</h2><p>在ICARUS主题的配置文件 _config.yml 文件中找到关键字 “menu” ，按如下方式修改并保存：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu</span><br><span class="line">	Home: /</span><br><span class="line">	Archives: /archives</span><br><span class="line">	Categories: /categories</span><br><span class="line">	Tags: /tags</span><br><span class="line">	About: /about               # 与该项修改一致即可</span><br></pre></td></tr></table></figure>
<h2 id="二：-“About”-页面的创建"><a href="#二：-“About”-页面的创建" class="headerlink" title="二： “About” 页面的创建"></a>二： “About” 页面的创建</h2><p>将 Git Bash 定位至 Hexo 配置文件所在目录下，运行如下指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;about&quot;</span><br></pre></td></tr></table></figure>
<p>此时会在 “source” 文件夹中生成一个名为 “about” 的文件夹，打开该文件夹中的 index.md 文件并添加自己需要展示的个人介绍等信息，保存后运行如下的指令进行博客的更新部署：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>ICARUS主题缩略图及文章目录的添加</title>
    <url>/2019/04/15/ICARUS%E4%B8%BB%E9%A2%98%E7%BC%A9%E7%95%A5%E5%9B%BE%E5%8F%8A%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95%E7%9A%84%E6%B7%BB%E5%8A%A0/</url>
    <content><![CDATA[<p>一：缩略图（thumbnail）的添加</p>
<p>二：目录（catalogue）的添加</p>
<a id="more"></a>
<h2 id="一：缩略图（thumbnail）的添加"><a href="#一：缩略图（thumbnail）的添加" class="headerlink" title="一：缩略图（thumbnail）的添加"></a>一：缩略图（thumbnail）的添加</h2><ol>
<li><p>首先将 ICARUS 主题的配置文件 <code>_config.yml</code> 中的 thumbnail 这一项设置成 “true”：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Article display setting</span><br><span class="line">thumbnail: true</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>/Hexo /scaffolds</code> 目录下的 <code>post</code> 文件中添加 thumbnail 这一项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">thumbnail:                  # 添加该项</span><br></pre></td></tr></table></figure>
</li>
<li><p>每次创建新的文件后，将要插入的缩略图的链接（URL）填入上述 thumbnail 后面即可。</p>
</li>
<li><p>缩略图如果在本地的话，则需要在  <code>/Hexo /source</code> 目录下新建一个名为 <code>gallery</code> 的文件夹，并将缩略图放在该文件夹中，这种情况下缩略图的路径格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thumbnail：/gallery/picturename.jpg</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="二：目录（catalogue）的添加"><a href="#二：目录（catalogue）的添加" class="headerlink" title="二：目录（catalogue）的添加"></a>二：目录（catalogue）的添加</h2><ol>
<li><p>在 <code>/Hexo /scaffolds</code> 目录下的 <code>post</code> 文件中添加 toc 这一项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">thumbnail: </span><br><span class="line">toc: true                    # 添加该项</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 ICARUS 主题的配置文件<code>_config.yml</code> 中添加 toc 控件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">widgets:</span><br><span class="line">    -</span><br><span class="line">        type: toc</span><br><span class="line">        position: left</span><br></pre></td></tr></table></figure>
<p>一般来说 toc 控件在ICARUS 主题的 <code>_config.yml</code> 配置文件中就已经存在的，已经有的情况下，就不需要再添加。 </p>
</li>
</ol>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>ICARUS</tag>
      </tags>
  </entry>
  <entry>
    <title>用又拍云进行图片云存储</title>
    <url>/2019/04/14/%E7%94%A8%E5%8F%88%E6%8B%8D%E4%BA%91%E8%BF%9B%E8%A1%8C%E5%9B%BE%E7%89%87%E4%BA%91%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<p>在 Markdown 文档中插入本地图片后，一旦出现图片存储位置发生改变、图片被删除、或者文档发送给别人后，文档中的图片将会失效。为了解决这个问题，同时为了节约本地服务器空间，加快图片访问速度，我们可以将图片存储于第三方平台上，这种平台即“图床”。</p>
<p>有很多免费的国内外 <a href="https://zhuanlan.zhihu.com/p/35270383" target="_blank" rel="noopener">图床</a> ，但是为了保证长期存储图片的安全，不会因为网站停止运营等情况导致图片的丢失，建议将重要的图片存储在像 “又拍云”、“七牛云” 等国内做得比较好的收费图床平台上。本文主要对又拍云上图片的上传方法和图片的引用方法做详细介绍。</p>
<a id="more"></a>
<h2 id="一：创建服务"><a href="#一：创建服务" class="headerlink" title="一：创建服务"></a>一：创建服务</h2><ol>
<li><p>首先进行 <a href="https://www.upyun.com/" target="_blank" rel="noopener">又拍云</a> 的注册及实名认证。</p>
</li>
<li><p>在 “云产品” 栏目下选择 “基础产品” 里面的 “云存储” ，然后在 “服务管理 云存储” 页面点击 “创建服务” 按照官方文档文档说明进行服务的创建和相关配置。完成后在 “云存储” 页面显示如下的信息说明创建成功：</p>
<p>| 服务名称 | 加速域名               | 应用场景 | 状态   | 管理     |<br>| ———— | ——————————— | ———— | ——— | ———— |<br>| blog-01  | blog-01.test.upcdn.net | 网页图片 | 服务中 | ———— |</p>
<p>其中：</p>
<p>blog-01 为自己创建的服务名；</p>
<p>blog-01.test.upcdn.net 为平台分配的测试域名。如果自己有注册并备案过的域名（没有进行备案无法绑定），绑定自己的域名最好。如果没有，则可以使用该测试域名，咨询过又拍云的客服人员，说该测试域名没有使用时间限制，可以保证一直正常访问。</p>
</li>
</ol>
<h2 id="二：本地图片的上传"><a href="#二：本地图片的上传" class="headerlink" title="二：本地图片的上传"></a>二：本地图片的上传</h2><ol>
<li><p>点击 “服务名称” （即上表中的 blog-01），进去后找 “内容管理” 这一项并点击进入，查看 “管理指南” 的 “详情”，可以看到又拍云提供了三种文件管理方式：“<strong>API(应用程序编程)</strong>”、“<strong>FTP(界面化工具)</strong>”、“<strong>UPX”(命令行工具)</strong>，官方文档对使用方法有详细的说明，可以根据自己的喜好进行文件管理方式的选择。下面主要介绍 <strong>FTP(界面化工具)</strong> 的使用方法：</p>
<p>通过 FTP/FTPS 客户端，可以连接云存储的 FTP/FTPS 服务器，实现对云存储的管理。推荐使用 <a href="https://www.filezilla.cn/download" target="_blank" rel="noopener">FileZilla 客户端</a> 。</p>
</li>
<li><p>FileZilla 客户端下载后，点击 “文件” 菜单下面那个按钮，将会出现如下图所示的 “站点管理器” 配置界面：</p>
<p><img src="http://blog-009.test.upcdn.net//2019-04-14-22-5-40.png" alt="站点管理器"></p>
</li>
</ol>
<p>   选择左下角的 “新站点” 然后进行相关的配置，主要参数填写如下：</p>
<p>   ——<strong>主机</strong> </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">智能线路</th>
<th style="text-align:center">电信线路</th>
<th style="text-align:center">联通线路</th>
<th style="text-align:center">移动线路</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">v0.ftp.upyun.com</td>
<td style="text-align:center">v1.ftp.upyun.com</td>
<td style="text-align:center">v2.ftp.upyun.com</td>
<td style="text-align:center">v3.ftp.upyun.com</td>
</tr>
</tbody>
</table>
</div>
<p>   推荐填写智能线路的 v0.ftp.upyun.com</p>
<p>   ——<strong>端口</strong> </p>
<p>   21</p>
<p>   ——<strong>用户/密码</strong>  </p>
<p>   例如我在 “服务创建” 中创建服务名称为 “blog-01” ，创建的操作员名称为 xavier ，操作员密码为 123456 ，则此处的用户名填写为：xavier/blog-01，密码填写123456即可。</p>
<p>   各参数填写完成后点击 “连接” 即可连接到云端，在FileZilla界面右侧栏会显示出远程站点及文件目录。</p>
<ol>
<li><p>将本地的图片拖到如下图所示的第4个区域即可实现上传：</p>
<p><img src="http://blog-009.test.upcdn.net//2019-04-14-22-30-24.png" alt="图片上传区域"></p>
</li>
<li><p>上传到云端的图片可以在FileZilla进行查看和操作，也可以在又拍云上进行查看和管理，地址为：<a href="https://uptool.tingfun.net/view/index.php" target="_blank" rel="noopener">https://uptool.tingfun.net/view/index.php</a> ，推荐后一种方法。</p>
</li>
</ol>
<h2 id="三：云端图片的引用"><a href="#三：云端图片的引用" class="headerlink" title="三：云端图片的引用"></a>三：云端图片的引用</h2><p>需要在 Markdown 编辑器中插入图片时，如下图所示，点击文件名即可对图片进行预览，将图片直接拖入 Markdown 编辑器中即可。</p>
<p><img src="http://blog-009.test.upcdn.net//2019-04-14-22-41-6.png" alt="图片的引用"></p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo 个性化域名的配置</title>
    <url>/2019/04/13/Hexo-%E4%B8%AA%E6%80%A7%E5%8C%96%E5%9F%9F%E5%90%8D%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>用 Hexo 框架结合 gitHub pages 搭建的个人博客默认的访问地址为 “<a href="https://yourname.github.io”" target="_blank" rel="noopener">https://yourname.github.io”</a> ，当然，我们也可以配置个性化的域名，个性化域名配置成功与否的关键在于域名解析是否正确。</p>
<a id="more"></a>
<h2 id="一：域名的购买"><a href="#一：域名的购买" class="headerlink" title="一：域名的购买"></a>一：域名的购买</h2><p>域名可在 <a href="https://wanwang.aliyun.com/" target="_blank" rel="noopener">阿里云</a> 根据自己对域名后缀的喜好和需求进行购买。</p>
<h2 id="二：域名的解析"><a href="#二：域名的解析" class="headerlink" title="二：域名的解析"></a>二：域名的解析</h2><p>1.登陆 <a href="https://wanwang.aliyun.com/" target="_blank" rel="noopener">阿里云</a> ，点击首页的 “控制台” 菜单：</p>
<p><img src="/2019/04/13/Hexo-个性化域名的配置/17-42.png" alt="&quot;控制台&quot;选项"></p>
<p>在控制台子项列表中选择 “域名” 选项：</p>
<p><img src="/2019/04/13/Hexo-个性化域名的配置/17-23.png" alt="&quot;域名&quot;选项"></p>
<p>在 “域名”  页面点击 “解析” 进行域名解析的相关操作与配置：</p>
<p><img src="/2019/04/13/Hexo-个性化域名的配置/17-25.png" alt="&quot;解析&quot;项"></p>
<p>2.在 “解析设置” 里，点击 “添加纪录” ，按如下的方式总共添加三条记录：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">记录类型</th>
<th style="text-align:center">主机记录</th>
<th style="text-align:center">解析线路(isp)</th>
<th style="text-align:center">记录值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">@</td>
<td style="text-align:center">默认</td>
<td style="text-align:center">xxx.xxx.xxx.xxx</td>
</tr>
<tr>
<td style="text-align:center">CNAME</td>
<td style="text-align:center">www</td>
<td style="text-align:center">默认</td>
<td style="text-align:center">yourname.github.io</td>
</tr>
</tbody>
</table>
</div>
<p>其中：</p>
<p>第一条记录值中的 “xxx.xxx.xxx.xxx” 填写自己 “yourname.github.io” 的 IP地址， 查询方式为在 cmd 命令行窗口中输入指令 “ping yourname.github.io” 进行查看，例如 185.199.108.154 ;</p>
<p>第二条记录值中的 “yourname.github.io” 为自己的博客地址，两条记录添加完之后，经过一定的时间域名解析即可完成。</p>
<h2 id="三：域名的绑定"><a href="#三：域名的绑定" class="headerlink" title="三：域名的绑定"></a>三：域名的绑定</h2><p>域名购买并解析成功后，在 <code>/source</code> 文件目录下新建一个不带后缀的名为 “CNAME” 的空白文件，以记事本打开后，输入购买的域名。例如所买的域名为 “123.com” ,则输入 “123.com” 即可，不用添加任何前缀。该文件保证了 “<a href="www.123.com">www.123.com</a>”、 “123.com”、 “yourname.github.io” 三种方式都能正常访问博客地址。</p>
<p>无后缀文件的创建可在 linux系统下用如下指令进行创建：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--- cd source                 # 先转到 /source 路径下</span><br><span class="line">--- touch CNAME               # CNAME 文件的创建</span><br></pre></td></tr></table></figure>
<p>“CNAME” 文件创建并修改完成后，经过博客的重新提交和部署即可用购买的域名进行访问。</p>
<p>如果无法进行访问，则有以下可能：</p>
<p>1.解析没有完成，一般需要在解析十分钟后域名才能生效，如果期间对记录值进行了修改，  也需要等一段时间。</p>
<p>2.域名没有完成实名认证，进行认证即可。</p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 只显示文章部分内容的设置</title>
    <url>/2019/04/12/Hexo-%E5%8F%AA%E6%98%BE%E7%A4%BA%E6%96%87%E7%AB%A0%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%E7%9A%84%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>当文章内容太长却在博客界面全文显示时，很影响其他文章内容的概览，为了让博客界面的每一篇文章只显示文章摘要等一小部分重要信息作为文章内容的预览，可采用 <code>&lt;!--more--&gt;</code> 手动进行文章内容的截断。</p>
<p>使用 <code>&lt;!--more--&gt;</code> 标签时，只需将其放在文中合适的位置即可。</p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 文中图片的插入</title>
    <url>/2019/04/12/Hexo-%E6%96%87%E4%B8%AD%E5%9B%BE%E7%89%87%E7%9A%84%E6%8F%92%E5%85%A5/</url>
    <content><![CDATA[<p>直接在 Markdown 编辑器中进行图片的插入会导致发布到博客后图片无法正常显示，本文主要介绍两种图片插入的方法。</p>
<a id="more"></a>
<h2 id="方法一：文章资源文件夹"><a href="#方法一：文章资源文件夹" class="headerlink" title="方法一：文章资源文件夹"></a>方法一：文章资源文件夹</h2><p>将 <code>\Hexo</code> 目录下的 <code>_config.yml</code> 配置文件中的 “post_asset_folder: false” 改为 “post_asset_folder: true”，再执行文章创建命令 <code>$ hexo new &quot;article title&quot;</code>  时，将会在  <code>\ _posts</code> 目录下生成一个与所创建的文章标题同名的文件夹。</p>
<p>将要插入的图片放在生成的该文件夹内，引用时，首先将图片拖入文中，然后对 Markdown 中图片的引用格式作如下的修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![图题](文章标题\picturename.png)</span><br></pre></td></tr></table></figure>
<p>其中 “picture name” 为所引用图片的名称。</p>
<p>通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确，为了解决这个问题，可以采用如下的方法进行图片的引用：</p>
<h2 id="方法二：相对路径引用的标签插件"><a href="#方法二：相对路径引用的标签插件" class="headerlink" title="方法二：相对路径引用的标签插件"></a>方法二：相对路径引用的标签插件</h2><p>标签插件的下载：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>
<p>或者通过：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image -- save</span><br></pre></td></tr></table></figure>
<p>插件下载成功后，将要插入的图片放在文章资源文件夹中，文章中图片的引用格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img picturename.jpg 图题 %&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 文章的发布</title>
    <url>/2019/04/12/Hexo-%E6%96%87%E7%AB%A0%E7%9A%84%E5%8F%91%E5%B8%83/</url>
    <content><![CDATA[<p>用 Hexo 框架结合 Github pages 搭建好博客平台后，接下来便是博客文章的创建和发布，本文主要对博客文章的创建和发布方法做了详细介绍。</p>
<a id="more"></a>
<h2 id="1-文章标题的创建"><a href="#1-文章标题的创建" class="headerlink" title="1.文章标题的创建"></a>1.文章标题的创建</h2><p>将Git Bash定位在 E:\Hexo_blog\Hexo 目录下，并运行如下指令创建一个带有标题的新空白文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;article title&quot;</span><br></pre></td></tr></table></figure>
<p>其中，E:\Hexo_blog 为 Hexo 的安装目录，E:\Hexo_blog\Hexo 为 Hexo 的初始化目录，“article title” 为博客文章的标题。</p>
<h2 id="2-文章信息的完善"><a href="#2-文章信息的完善" class="headerlink" title="2.文章信息的完善"></a>2.文章信息的完善</h2><p>执行上述指令后，将会在 E:\Hexo_blog\Hexo\source_posts 文件目录下生成一个名为 “article title” 格式为 .md 的文档，用 Markdown 编辑器进行所创建文档的编辑，完善 “tags”，“categories” 等信息，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: &quot;article title&quot;                # 文章标题</span><br><span class="line">date: 2019-04-10 10:48:14             # 文章创建时间</span><br><span class="line">tags: [ubuntu,windows]                # 标签信息</span><br><span class="line">categories: operate system            # 分类信息</span><br></pre></td></tr></table></figure>
<p>“tags”、“categories” 等项可以在/Hexo/scaffolds目录下的“post”文件中作相应的修改，可以根据实际需求添加该项或者删除该项。</p>
<h2 id="3-文章的预览和发布"><a href="#3-文章的预览和发布" class="headerlink" title="3.文章的预览和发布"></a>3.文章的预览和发布</h2><p>将编辑完的文章保存，运行如下指令即可进行文章样式的预览和将本地文章发布到博客网站：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g             # 生成静态文件</span><br><span class="line">hexo s             # 预览</span><br><span class="line">hexo d             # 部署</span><br></pre></td></tr></table></figure>
<p>运行 <code>hexo s</code> 进行预览时，如果用 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 访问出现加载无效的问题，则有可能默认端口被占用，换个端口即可，比如将4000换为4001，端口切换指令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s -p 4001</span><br></pre></td></tr></table></figure>
<h2 id="4-博客文章的访问"><a href="#4-博客文章的访问" class="headerlink" title="4.博客文章的访问"></a>4.博客文章的访问</h2><p>文章部署完成后，即可通过搜索引擎访问 “<a href="https://suyuann.github.io”" target="_blank" rel="noopener">https://suyuann.github.io”</a>  进行新发布文章的查询。</p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 常用指令</title>
    <url>/2019/04/12/Hexo-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>Hexo 是一个快速、简洁而且高效的博客框架，本文主要对 Hexo 的常用指令含义和用法作简要说明。</p>
<a id="more"></a>
<p> <img src="/2019/04/12/Hexo-常用指令/hexo01.png" alt="Hexo主要指令"></p>
<h2 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
<p>清除缓存文件（<code>db.json</code>）和已经生成的静态文件（<code>public</code>）</p>
<p>当 Hexo 更改新的主题后或者创建新的文章后，有时候会出现即使提交部署博客页面仍不见更新的情况，此时便可能需要执行此命令。</p>
<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;article title&quot;</span><br></pre></td></tr></table></figure>
<p>创建一篇名为 “article title” 的博客。如果标题包含空格，则需要用双引号括起来。</p>
<h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<p>生成静态网页。</p>
<h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>启动服务器。对 “generate” 生成的静态网页样式进行预览。</p>
<h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>网站部署，部署 “generate” 生成的静态网页。</p>
<h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo默认在目前的文件夹建立网站。</p>
<h2 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo migrate</span><br></pre></td></tr></table></figure>
<p>从其他博客系统 <a href="https://hexo.io/zh-cn/docs/migration" target="_blank" rel="noopener">迁移内容</a>。</p>
<h2 id="version"><a href="#version" class="headerlink" title="version"></a>version</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo version</span><br></pre></td></tr></table></figure>
<p>查看 Hexo 的版本信息。</p>
<blockquote>
<p>参考文献：<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo文档</a>  </p>
</blockquote>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/04/10/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
